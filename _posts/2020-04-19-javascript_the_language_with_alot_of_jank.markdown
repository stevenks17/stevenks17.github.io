---
layout: post
title:      "Javascript the language with alot of jank"
date:       2020-04-19 22:05:09 -0400
permalink:  javascript_the_language_with_alot_of_jank
---


 Going into javascript I was a bit familiar with the core concepts as I had touched on them a bit in highschool. But the javascript I used in highschool had evolved and learned a couple new tricks. Alot of the initial problem I had with the language stemmed from a completely other problem and that was I had been learning Ruby and the frameworks to utilize it better before this. With that the general flow and concepts of how JS works are different as you can truly do anything with it but you have to be very specific about implementation. With Ruby and the Rails framework  both are very forgiving and can be fairly intuitive with what you are trying to accomplish. Going into my javascript front end for my project where I could have used form_for in rails I saw that with javascript its more involved as you can have a form but you have to create all of it. But with that comes the open ended ability to design and style it however you want and make it as interactive as you want. Javascript does definitely have its oddities though, one being almost everything is undefined on declaration till you call it. 

 This took some getting used to as I was constantly wondering if this had been setup properly or not. But being able to use the developer tools in Google Chrome have been great. They make it very easy to test and see exactly how your code will function. The caveat or possible benefit with Javascript is that it all fails on execution so in that aspect it is very test driven in a way unless you start using async functionality but even then it will still show you in execution what failed. I think my past experience with Ruby as a language has been a great benefit when it comes to learning javascript because of how much control and creativity that you can have when using it. Some of the jank and oddities with the language are very interesting such as that NULL is an object. Funny because in general null is normally the complete absence of meaning or value for something. Another weird implementation is that NaN which stands for "Not a Number" is quantified as a number in javascript but it is not equal to itself that definitely threw me for a loop and still does. I guess the point of all of this is that javascript seeks to abstract as much as possible for the benefit of making future implementation smarter on its own so we have to create applications  less programatically and more intuitively.
 
 An important concept that can be core to certain web applications is the fetch and post request cycles and then subsequently rendering the response to the DOM. A fetch request is the act of grabbing data from another source in most cases a backend API and returning it as a promise. A promise in general terms is an object that comes back that needs to be converted before we can utilize it. Using promises lets us handle requests asynchronously meaning these requests can occur without slowing down or causing a crash on our website should the request fail.  To clarify the fact that these requests are done asynchronously means by default they are not synchornous and what this means is they can be completed at any given time and that the data is being intermittedly transmitted as available. This is a preferred method because handling these fetch requests synchronously would slow down the entire flow of our web applications because one event would be awaiting the completion of another and if one breaks they could all potentially break.
 
 
  Moving on from synchronicity we currently have the data being pulled in but not as a JSON just yet we need to convert the fetch promise into a JSON by taking the response and using `(response => response.json() )` to complete that action. Now we have the data as a JSON and can run it through a callback function to use it in our frontend this can be done by  a `.then( data => renderMovies(data) )` .  From here you can use the passed in information from the backend in any number of ways. In most cases bringing this data to the frontend means at some point you would like to display it. To achieve that you would want to pass in the new data you recieved to a function and then use this function in a JS file to render the information. 
	
	From the backend perspective once a fetch request is made the backend will look for the specific controller action to match the request if one is specified. It will then execute the controller logic  which generally is to query the database and pass back the search results thus going back to the front end with data and from there we continue the loop of fetch requests and returned promises converting the data into a JSON for use in the front end.
 
Rendering the retrieved data is accomplished by using Javascript to implement the logic to render and using HTML to display it by executing the logic you created in your js file. In general most of your logic will be shaped around a container for the information so it will be easier once displayed to implement future logic. A broadview image of what the process looks like is below to visualize the flow for this process.

![flowchart](https://storage.googleapis.com/zingchart-blog/zing-content/2017/12/fetch-diagram-1.png)

All in all this a rather small piece of all the capability that is wrapped into Javascript and it is also only the start point in most cases of using Javascript.


  
